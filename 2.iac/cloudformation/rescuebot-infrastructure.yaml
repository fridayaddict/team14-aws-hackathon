AWSTemplateFormatVersion: '2010-09-09'
Description: 'Rescue Bot Infrastructure - MySQL monitoring and auto-recovery system'

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, prod]
  
  ProjectName:
    Type: String
    Default: rescuebot

  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Mappings:
  EnvironmentMap:
    dev:
      InstanceType: t3.micro
      DBInstanceClass: db.t3.micro
      MultiAZ: false
    prod:
      InstanceType: t3.medium
      DBInstanceClass: db.t3.medium
      MultiAZ: true

Resources:
  # VPC
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-vpc

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-igw

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  # Public Subnets
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-public-1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-public-2

  # Route Table
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-public-rt

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetRouteTableAssociation2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  # Security Groups
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Application Load Balancer
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-alb-sg

  FlaskSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Flask app servers
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5000
          ToPort: 5000
          SourceSecurityGroupId: !Ref ALBSecurityGroup
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-flask-sg

  MonitoringSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for monitoring target server
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-monitoring-sg

  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for RDS MySQL
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          SourceSecurityGroupId: !Ref FlaskSecurityGroup
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-rds-sg



  # IAM Roles
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: RescueBotEC2Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - sns:Publish
                  - secretsmanager:GetSecretValue
                  - bedrock:InvokeModel
                Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2Role

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RescueBotLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                  - bedrock:InvokeModel
                Resource: '*'

  # Key Pair
  EC2KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Sub ${ProjectName}-keypair

  # Secrets Manager
  DBPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub ${ProjectName}-db-credentials
      GenerateSecretString:
        SecretStringTemplate: '{"username": "admin"}'
        GenerateStringKey: 'password'
        PasswordLength: 16
        ExcludeCharacters: '"@/\'

  # RDS
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS MySQL
      SubnetIds:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-db-subnet-group

  RDSInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub ${ProjectName}-mysql
      DBInstanceClass: !FindInMap [EnvironmentMap, !Ref Environment, DBInstanceClass]
      Engine: mysql
      EngineVersion: '8.0'
      AllocatedStorage: 20
      StorageType: gp2
      DBName: rescuebot
      MasterUsername: admin
      MasterUserPassword: !Sub '{{resolve:secretsmanager:${DBPassword}:SecretString:password}}'
      VPCSecurityGroups:
        - !Ref RDSSecurityGroup
      DBSubnetGroupName: !Ref DBSubnetGroup
      BackupRetentionPeriod: 7
      MultiAZ: !FindInMap [EnvironmentMap, !Ref Environment, MultiAZ]
      PubliclyAccessible: true
      DeletionProtection: false



  # Flask App Instance
  FlaskAppInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: !FindInMap [EnvironmentMap, !Ref Environment, InstanceType]
      KeyName: !Ref EC2KeyPair
      IamInstanceProfile: !Ref EC2InstanceProfile
      SecurityGroupIds:
        - !Ref FlaskSecurityGroup
      SubnetId: !Ref PublicSubnet1
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y mariadb-server python3 git
          
          # Start MariaDB
          systemctl start mariadb
          systemctl enable mariadb
          
          git clone https://github.com/fridayaddict/team14-aws-hackathon.git
          
          
          # Set MariaDB root password
          mysql -e "SET PASSWORD FOR 'root'@'localhost' = PASSWORD('flaskdb123');"
          mysql -u root -pflaskdb123 -e "CREATE DATABASE IF NOT EXISTS rescuebot;"
          mysql -u root -pflaskdb123 -e "CREATE USER 'rescuebot'@'%' IDENTIFIED BY 'rescuebot123';"
          mysql -u root -pflaskdb123 -e "GRANT ALL PRIVILEGES ON rescuebot.* TO 'rescuebot'@'%';"
          mysql -u root -pflaskdb123 -e "FLUSH PRIVILEGES;"
          
          # Configure MariaDB for remote access
          echo "[mysqld]" >> /etc/my.cnf
          echo "bind-address = 0.0.0.0" >> /etc/my.cnf
          systemctl restart mariadb
          
          # Install pip packages
          pip3 install flask boto3 pymysql flask-sqlalchemy
          
          # Create Flask app directory
          mkdir -p /opt/rescuebot
          
          # Create Flask app
          cat > /opt/rescuebot/app.py << 'EOF'
          from flask import Flask, request, jsonify
          from flask_sqlalchemy import SQLAlchemy
          import boto3
          import json
          import os
          from datetime import datetime
          
          app = Flask(__name__)
          # Use both local MySQL and RDS
          app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://rescuebot:rescuebot123@localhost/rescuebot'
          app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
          
          db = SQLAlchemy(app)
          
          # Database Models
          class CloudWatchEvent(db.Model):
              id = db.Column(db.Integer, primary_key=True)
              event_source = db.Column(db.String(100))
              event_type = db.Column(db.String(50))
              severity = db.Column(db.String(20))
              server_id = db.Column(db.String(50))
              event_message = db.Column(db.Text)
              event_time = db.Column(db.DateTime, default=datetime.utcnow)
              status = db.Column(db.String(20), default='new')
          
          @app.route('/health', methods=['GET'])
          def health():
              return jsonify({'status': 'healthy', 'timestamp': datetime.utcnow().isoformat()})
          
          @app.route('/webhook/cloudwatch', methods=['POST'])
          def cloudwatch_webhook():
              try:
                  data = request.get_json()
                  print(f"Received CloudWatch event: {data}")
                  
                  # Save event to database
                  event = CloudWatchEvent(
                      event_source=data.get('source', 'cloudwatch'),
                      event_type=data.get('alert', 'mysql_down'),
                      severity='critical',
                      server_id=data.get('server', 'unknown'),
                      event_message=str(data),
                      status='processing'
                  )
                  db.session.add(event)
                  db.session.commit()
                  
                  # Call Bedrock for AI response
                  bedrock = boto3.client('bedrock-runtime', region_name='${AWS::Region}')
                  
                  prompt = f"MySQL service is down on server {data.get('server', 'unknown')}. Provide step-by-step troubleshooting guide."
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-sonnet-20240229-v1:0',
                      body=json.dumps({
                          "anthropic_version": "bedrock-2023-05-31",
                          "max_tokens": 1000,
                          "messages": [
                              {
                                  "role": "user",
                                  "content": prompt
                              }
                          ]
                      })
                  )
                  
                  result = json.loads(response['body'].read())
                  ai_solution = result['content'][0]['text']
                  
                  # Update event status
                  event.status = 'resolved'
                  db.session.commit()
                  
                  return jsonify({
                      'status': 'success',
                      'event_id': event.id,
                      'ai_solution': ai_solution
                  })
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return jsonify({'error': str(e)}), 500
          
          @app.route('/events', methods=['GET'])
          def get_events():
              events = CloudWatchEvent.query.order_by(CloudWatchEvent.event_time.desc()).limit(50).all()
              return jsonify([
                  {
                      'id': e.id,
                      'event_type': e.event_type,
                      'severity': e.severity,
                      'server_id': e.server_id,
                      'event_time': e.event_time.isoformat(),
                      'status': e.status
                  } for e in events
              ])
          
          if __name__ == '__main__':
              with app.app_context():
                  db.create_all()
              app.run(host='0.0.0.0', port=5000, debug=True)
          EOF
          
          # Create systemd service
          cat > /etc/systemd/system/rescuebot.service << 'EOF'
          [Unit]
          Description=Rescue Bot Flask App
          After=network.target mariadb.service
          Requires=mariadb.service
          
          [Service]
          Type=simple
          User=ec2-user
          WorkingDirectory=/opt/rescuebot
          ExecStart=/usr/bin/python3 /opt/rescuebot/app.py
          Restart=always
          RestartSec=10
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # Start Flask app
          systemctl daemon-reload
          systemctl enable rescuebot
          systemctl start rescuebot
          
          echo "Flask App Server with MySQL Ready" > /var/log/flask-ready.log
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-flask-server

  # Monitoring Target Server
  MonitoringTargetInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: !FindInMap [EnvironmentMap, !Ref Environment, InstanceType]
      KeyName: !Ref EC2KeyPair
      IamInstanceProfile: !Ref EC2InstanceProfile
      SecurityGroupIds:
        - !Ref MonitoringSecurityGroup
      SubnetId: !Ref PublicSubnet2
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y mariadb-server python3
          
          # Start MariaDB
          systemctl start mariadb
          systemctl enable mariadb
          
          # Set MariaDB root password
          mysql -e "SET PASSWORD FOR 'root'@'localhost' = PASSWORD('password123');"
          mysql -u root -ppassword123 -e "CREATE DATABASE IF NOT EXISTS testdb;"
          mysql -u root -ppassword123 -e "CREATE USER 'testuser'@'%' IDENTIFIED BY 'testpass';"
          mysql -u root -ppassword123 -e "GRANT ALL PRIVILEGES ON testdb.* TO 'testuser'@'%';"
          mysql -u root -ppassword123 -e "FLUSH PRIVILEGES;"
          
          # Configure MariaDB for remote access
          echo "[mysqld]" >> /etc/my.cnf
          echo "bind-address = 0.0.0.0" >> /etc/my.cnf
          systemctl restart mariadb
          
          # Install CloudWatch Agent
          wget https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
          rpm -U ./amazon-cloudwatch-agent.rpm
          
          # CloudWatch Agent Configuration
          cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
          {
            "metrics": {
              "namespace": "CWAgent",
              "metrics_collected": {
                "cpu": {
                  "measurement": ["cpu_usage_idle", "cpu_usage_iowait"],
                  "metrics_collection_interval": 60
                },
                "netstat": {
                  "measurement": ["tcp_established", "tcp_listen"],
                  "metrics_collection_interval": 60
                },
                "procstat": [
                  {
                    "pattern": "mysqld",
                    "measurement": ["cpu_usage", "memory_rss", "pid_count"]
                  }
                ]
              }
            },
            "logs": {
              "logs_collected": {
                "files": {
                  "collect_list": [
                    {
                      "file_path": "/var/log/port_check.log",
                      "log_group_name": "/aws/ec2/rescuebot",
                      "log_stream_name": "{instance_id}"
                    }
                  ]
                }
              }
            }
          }
          EOF
          
          # Start CloudWatch Agent
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
            -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
          
          # Create port check script
          cat > /opt/check_mysql_port.py << 'EOF'
          #!/usr/bin/env python3
          import boto3
          import socket
          import requests
          
          def check_port_3306():
              cloudwatch = boto3.client('cloudwatch', region_name='${AWS::Region}')
              
              # Get instance ID
              try:
                  instance_id = requests.get('http://169.254.169.254/latest/meta-data/instance-id', timeout=2).text
              except:
                  instance_id = 'unknown'
              
              try:
                  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  sock.settimeout(5)
                  result = sock.connect_ex(('localhost', 3306))
                  sock.close()
                  
                  port_status = 1 if result == 0 else 0
                  
                  cloudwatch.put_metric_data(
                      Namespace='Custom/MySQL',
                      MetricData=[
                          {
                              'MetricName': 'Port3306Status',
                              'Value': port_status,
                              'Unit': 'Count',
                              'Dimensions': [
                                  {
                                      'Name': 'InstanceId',
                                      'Value': instance_id
                                  }
                              ]
                          }
                      ]
                  )
                  print(f"Port 3306 status: {port_status} for instance: {instance_id}")
              except Exception as e:
                  print(f"Error checking port: {e}")
          
          if __name__ == "__main__":
              check_port_3306()
          EOF
          
          chmod +x /opt/check_mysql_port.py
          echo "*/1 * * * * /usr/bin/python3 /opt/check_mysql_port.py >> /var/log/port_check.log 2>&1" | crontab -
          
          echo "Monitoring Server Ready" > /var/log/monitoring-ready.log
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-monitoring-target

  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${ProjectName}-alb
      Scheme: internet-facing
      Type: application
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${ProjectName}-tg
      Port: 5000
      Protocol: HTTP
      VpcId: !Ref VPC
      Targets:
        - Id: !Ref FlaskAppInstance
          Port: 5000
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2

  Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP

  # SNS Topic
  AlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub ${ProjectName}-alerts

  # CloudWatch Alarm
  MySQLPortAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${ProjectName}-mysql-port-down
      AlarmDescription: MySQL port 3306 status monitoring
      MetricName: Port3306Status
      Namespace: Custom/MySQL
      Statistic: Average
      Period: 60
      EvaluationPeriods: 2
      Threshold: 1
      ComparisonOperator: LessThanThreshold
      AlarmActions:
        - !Ref AlertsTopic

  # Lambda Function for Alert Handling
  AlertHandlerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ProjectName}-alert-handler
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 60
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref AlertsTopic
          FLASK_API_URL: !Sub 'http://${ApplicationLoadBalancer.DNSName}'
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import os
          
          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")
              
              sns = boto3.client('sns')
              http = urllib3.PoolManager()
              
              message = {
                  "alert": "MySQL Port 3306 Down",
                  "server": event.get('detail', {}).get('dimensions', {}).get('InstanceId', 'unknown'),
                  "timestamp": event.get('time', 'unknown')
              }
              
              try:
                  # Send SNS notification
                  sns.publish(
                      TopicArn=os.environ['SNS_TOPIC_ARN'],
                      Message=json.dumps(message),
                      Subject="MySQL Alert - Port Down"
                  )
                  
                  # Call Flask API webhook
                  flask_url = f"{os.environ['FLASK_API_URL']}/webhook/cloudwatch"
                  response = http.request('POST', flask_url, 
                                        body=json.dumps(message),
                                        headers={'Content-Type': 'application/json'})
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Alert processed successfully')
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }

  # Bedrock Lambda Function
  BedrockChatFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ProjectName}-bedrock-chat
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          
          def lambda_handler(event, context):
              bedrock = boto3.client('bedrock-runtime')
              
              try:
                  prompt = event.get('prompt', 'Hello, how can I help with MySQL troubleshooting?')
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-sonnet-20240229-v1:0',
                      body=json.dumps({
                          "anthropic_version": "bedrock-2023-05-31",
                          "max_tokens": 1000,
                          "messages": [
                              {
                                  "role": "user",
                                  "content": prompt
                              }
                          ]
                      })
                  )
                  
                  result = json.loads(response['body'].read())
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'response': result['content'][0]['text']
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }

  # EventBridge Rule
  MySQLAlertRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub ${ProjectName}-mysql-alert-rule
      Description: Capture MySQL port down events
      EventPattern:
        source:
          - aws.cloudwatch
        detail-type:
          - CloudWatch Alarm State Change
        detail:
          alarmName:
            - !Ref MySQLPortAlarm
          state:
            value:
              - ALARM
      Targets:
        - Arn: !GetAtt AlertHandlerFunction.Arn
          Id: MySQLAlertLambdaTarget

  # Lambda Permissions
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref AlertHandlerFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt MySQLAlertRule.Arn

Outputs:
  VPCId:
    Description: VPC ID
    Value: !Ref VPC

  LoadBalancerDNS:
    Description: Load Balancer DNS name
    Value: !GetAtt ApplicationLoadBalancer.DNSName

  FlaskAppURL:
    Description: Flask application URL
    Value: !Sub 'http://${ApplicationLoadBalancer.DNSName}'

  RDSEndpoint:
    Description: RDS endpoint
    Value: !GetAtt RDSInstance.Endpoint.Address

  FlaskMySQLCommand:
    Description: Connect to Flask server MySQL
    Value: !Sub 'mysql -h ${FlaskAppInstance.PublicIp} -P 3306 -u rescuebot -p'

  RDSMySQLCommand:
    Description: Connect to RDS MySQL
    Value: !Sub 'mysql -h ${RDSInstance.Endpoint.Address} -P 3306 -u admin -p'

  FlaskInstanceId:
    Description: Flask server instance ID
    Value: !Ref FlaskAppInstance

  FlaskInstanceIP:
    Description: Flask server public IP
    Value: !GetAtt FlaskAppInstance.PublicIp

  MonitoringInstanceId:
    Description: Monitoring target instance ID
    Value: !Ref MonitoringTargetInstance

  MonitoringInstanceIP:
    Description: Monitoring target instance public IP
    Value: !GetAtt MonitoringTargetInstance.PublicIp

  BedrockChatFunctionArn:
    Description: Bedrock Chat Lambda function ARN
    Value: !GetAtt BedrockChatFunction.Arn

  MySQLConnectionCommand:
    Description: Connect to monitoring target MySQL
    Value: !Sub 'mysql -h ${MonitoringTargetInstance.PublicIp} -P 3306 -u root -p'

  FlaskMySQLPassword:
    Description: Flask MySQL password
    Value: 'rescuebot123'

  MonitoringMySQLPassword:
    Description: Monitoring MySQL password
    Value: 'password123'